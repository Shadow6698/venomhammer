game:GetService("StarterGui"):SetCore("SendNotification",{
    Title = "ðŸ”¥ FE Ban Hammer Loaded!",
    Text = "By Jinxx0g - Persistent Bug System",
    Duration = 10
})

-- ServiÃ§os
local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local RunService = game:GetService("RunService")
local LocalPlayer = Players.LocalPlayer

-- VariÃ¡veis
local buggedPlayers = {} -- [playerName] = true/false
local bugConnections = {} -- [playerName] = RunService.Heartbeat connection
local Remote = ReplicatedStorage:FindFirstChild("RE") and ReplicatedStorage.RE:FindFirstChild("1Gu1n")

-- NotificaÃ§Ã£o rÃ¡pida
local function createNotification(title, message)
    pcall(function()
        game:GetService("StarterGui"):SetCore("SendNotification",{
            Title = title,
            Text = message,
            Duration = 4
        })
    end)
end

-- FunÃ§Ã£o que aplica bug persistente
local function applyBugPersistent(target)
    if not target then return end
    if buggedPlayers[target.Name] then return end -- jÃ¡ bugado

    buggedPlayers[target.Name] = true
    createNotification("ðŸ”¨ Bug Aplicado", target.Name.." estÃ¡ sendo bugado!")

    local function applyToCharacter(char)
        local hrp = char:WaitForChild("HumanoidRootPart", 5)
        if not hrp then return end

        -- Remove conexÃ£o antiga
        if bugConnections[target.Name] then
            bugConnections[target.Name]:Disconnect()
            bugConnections[target.Name] = nil
        end

        -- ConexÃ£o contÃ­nua
        bugConnections[target.Name] = RunService.Heartbeat:Connect(function()
            if not hrp.Parent then return end
            local crazyVector = Vector3.new(
                math.random(-1e7,1e7),
                math.random(-1e7,1e7),
                math.random(-1e7,1e7)
            )

            local args = {
                [1] = hrp,
                [2] = hrp,
                [3] = crazyVector,
                [4] = hrp.Position,
                [5] = LocalPlayer.Backpack:FindFirstChild("Assault") and LocalPlayer.Backpack.Assault:FindFirstChild("GunScript_Local"):FindFirstChild("MuzzleEffect"),
                [6] = LocalPlayer.Backpack:FindFirstChild("Assault") and LocalPlayer.Backpack.Assault:FindFirstChild("GunScript_Local"):FindFirstChild("HitEffect"),
                [7] = 10000,
                [8] = 10000,
                [9] = { [1] = false },
                [10] = {
                    [1] = 10000,
                    [2] = Vector3.new(3000,3000,3000),
                    [3] = BrickColor.new(29),
                    [4] = 0.05,
                    [5] = Enum.Material.SmoothPlastic,
                    [6] = 0.05
                },
                [11] = true,
                [12] = false
            }

            Remote:FireServer(unpack(args))
        end)
    end

    -- Aplica imediatamente
    if target.Character then
        applyToCharacter(target.Character)
    end

    -- Aplica ao respawn
    target.CharacterAdded:Connect(function(char)
        applyToCharacter(char)
    end)
end

-- Remove bug
local function removeBugPersistent(target)
    if target and buggedPlayers[target.Name] then
        buggedPlayers[target.Name] = nil
        if bugConnections[target.Name] then
            bugConnections[target.Name]:Disconnect()
            bugConnections[target.Name] = nil
        end
        createNotification("ðŸ”“ Desbugado", target.Name.." voltou ao normal!")
    end
end

-- Alterna bug ao clicar
local function toggleBug(target)
    if buggedPlayers[target.Name] then
        removeBugPersistent(target)
    else
        applyBugPersistent(target)
    end
end

-- Detecta player clicado
local function getPlayerFromMouse(mouse)
    local target = mouse.Target
    if not target then return nil end

    local character = target.Parent
    while character and not character:FindFirstChild("Humanoid") do
        character = character.Parent
    end

    if character and character:FindFirstChild("Humanoid") then
        return Players:GetPlayerFromCharacter(character)
    end
    return nil
end

-- Criar Tool
local tool = Instance.new("Tool")
tool.Name = "Bug Hammer"
tool.RequiresHandle = true
tool.CanBeDropped = true

local handle = Instance.new("Part")
handle.Name = "Handle"
handle.Size = Vector3.new(0.3,0.3,0.3)
handle.Massless = true
handle.Anchored = false
handle.CanCollide = false
handle.Color = Color3.fromRGB(255,0,0)
handle.Transparency = 0.3

local mesh = Instance.new("SpecialMesh", handle)
mesh.MeshType = Enum.MeshType.Sphere
mesh.Scale = Vector3.new(0.2,0.2,0.2)
handle.Parent = tool

-- Equipar Tool
tool.Equipped:Connect(function(mouse)
    local character = tool.Parent
    if character and character:FindFirstChild("Humanoid") and character.Humanoid.RigType == Enum.HumanoidRigType.R15 then
        
        -- Equipar aparÃªncia
        local args = {15250088977}
        game:GetService("ReplicatedStorage"):WaitForChild("Remotes"):WaitForChild("Wear"):InvokeServer(unpack(args))
        
        -- Clique do mouse
        mouse.Button1Down:Connect(function()
            local targetPlayer = getPlayerFromMouse(mouse)
            if targetPlayer and targetPlayer ~= LocalPlayer then
                toggleBug(targetPlayer)

                -- Toca animaÃ§Ã£o de ataque
                local humanoid = character:FindFirstChildOfClass("Humanoid")
                local animator = humanoid and humanoid:FindFirstChildOfClass("Animator")
                if animator then
                    local anim = Instance.new("Animation")
                    anim.AnimationId = "rbxassetid://2410679501"
                    local track = animator:LoadAnimation(anim)
                    track:Play()
                end
            else
                createNotification("ðŸ’¡ Info", "Clique em um player para aplicar/remover bug!")
            end
        end)

        createNotification("ðŸ”¨ Equipado", "Clique em players para aplicar ou remover bug.")
    end
end)

tool.Unequipped:Connect(function()
    createNotification("ðŸ”¨ Guardado", "Bug Hammer foi desequipado.")
end)

-- Limpar conexÃµes quando player sair
Players.PlayerRemoving:Connect(function(player)
    removeBugPersistent(player)
end)

-- Comando para parar todos os bugs
LocalPlayer.Chatted:Connect(function(msg)
    if msg:lower() == "/stopallbugs" then
        for _, conn in pairs(bugConnections) do
            if conn then conn:Disconnect() end
        end
        bugConnections = {}
        buggedPlayers = {}
        createNotification("ðŸ›‘ Stop", "Todos os players foram desbugados!")
    end
end)

-- Dar Tool
tool.Parent = LocalPlayer.Backpack
createNotification("âœ… Carregado", "Bug Hammer adicionado ao inventÃ¡rio!")
